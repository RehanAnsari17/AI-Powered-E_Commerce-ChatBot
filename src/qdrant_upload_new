from qdrant_client import QdrantClient
from qdrant_client.http.models import PointStruct, VectorParams, Distance
from uuid import uuid4
from tqdm import tqdm
import pandas as pd
import numpy as np

# === Load metadata and embeddings ===
print("üîπ Loading metadata and embeddings...")
df = pd.read_csv(r'D:\AI-Powered-E_Commerce-ChatBot\src\cloudinary_uploaded_data.csv')
embeddings = np.load(r'D:\AI-Powered-E_Commerce-ChatBot\src\image_metadata_embeddings.npy')

assert len(df) == embeddings.shape[0], "‚ùå Mismatch between metadata and embeddings"


df = df.head(150000)
embeddings = embeddings[:150000]
# === Connect to Qdrant Cloud via HTTP ===
print("üîπ Connecting to Qdrant Cloud...")
client = QdrantClient(
    host="",
    api_key=""
    # Removed gRPC and port for safer HTTP fallback
)

collection_name = "my_collection"

# === Recreate collection ===
print(f"üîπ Recreating collection '{collection_name}'...")
client.recreate_collection(
    collection_name=collection_name,
    vectors_config=VectorParams(
        size=384,  # Confirm this is the correct embedding dimension
        distance=Distance.COSINE
    )
)

# === Upload data in batches ===
BATCH_SIZE = 100
all_points = []

print("üîπ Starting upload to Qdrant...")
for idx, row in tqdm(df.iterrows(), total=len(df)):
    metadata = {
        "id": str(row.get("id", "")),
        "image_url": row.get("image_url", ""),
        "gender": row.get("gender", ""),
        "masterCategory": row.get("masterCategory", ""),
        "subCategory": row.get("subCategory", ""),
        "articleType": row.get("articleType", ""),
        "baseColour": row.get("baseColour", ""),
        "season": row.get("season", ""),
        "year": str(row.get("year", "")),
        "usage": row.get("usage", ""),
        "productDisplayName": row.get("productDisplayName", "")
    }

    all_points.append(
        PointStruct(
            id=str(uuid4()),
            vector=embeddings[idx].tolist(),
            payload=metadata
        )
    )

    # Upload in batches
    if len(all_points) == BATCH_SIZE:
        client.upsert(collection_name=collection_name, points=all_points)
        all_points = []

# Upload remaining points
if all_points:
    client.upsert(collection_name=collection_name, points=all_points)

print("‚úÖ Upload complete!")
